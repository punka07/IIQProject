<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell" name="cobUtils">
  <Source><![CDATA[
 
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TimeZone;
import javax.naming.CompoundName;
import javax.naming.Context;
import javax.naming.InvalidNameException;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.BasicAttribute;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.ModificationItem;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import sailpoint.api.PasswordGenerator;
import sailpoint.api.SailPointContext;
import sailpoint.object.Application;
import sailpoint.object.Custom;
import sailpoint.object.Filter;
import sailpoint.object.Filter.MatchMode;
import sailpoint.object.Identity;
import sailpoint.object.PasswordPolicy;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.QueryOptions;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Util;
  
  
   
	public static String toStartCase(String word) {
		String result = null;
		if (word != null) {
			if (word.length() < 2) {
				result = word.toUpperCase();
			} else {
				boolean wordBeginning = true;
				StringBuilder sb = new StringBuilder();
				for (int i = 0; i< word.length(); i++) {
					Character ch = word.charAt(i);
					if (Character.isLetterOrDigit(ch)) {
						if (wordBeginning) {
							sb.append(Character.toUpperCase(ch));
							wordBeginning = false;
						} else {
							sb.append(Character.toLowerCase(ch));
						}
					} else {
						sb.append(ch);
						if (!wordBeginning) {
							wordBeginning = Character.getType(ch) == Character.DASH_PUNCTUATION || Character.getType(ch) == Character.SPACE_SEPARATOR;
						}
					}
				}
				result = sb.toString();
			}
		}
		//
		return result;
	}

	/**
	 * @param name
	 * @returns A copy of the name with all non-word characters removed except dash and space.
	 *
	 * 
	 */
	public static String normalizeName(String name) {
		if (name == null) {
			return name;
		} else {
			return name.replaceAll("[^a-zA-Z0-9- ]", "");
		}
	}

	 
	 
	 /**
	 *
	 * @param str
	 * @returns
	 * 			A copy of the string, with whitespace normalized by
	 *          stripping leading and trailing whitespace and replacing sequences of
	 *          whitespace characters by a single space.
	 *
	 * 
	 */
	public static String trimAndNormalizeWhiteSpaces(String str) {
		if (str == null) {
			return str;
		} else {
			return str.trim().replaceAll("\\s{2,}", " ");
		}
	}

	public static String[] commonSuffixes = new String[] { " senior", " sr.", " sr", " junior", " jr.", " jr", " viii", " vii", " iii", " ii",
			" iv", " vi", " ix", " i", " v", " x" };

	/**
	 * Removes post fix salutations like Jr., Sr., III from name.
	 *
	 * @param lastName
	 * @returns {java.lang.String} name
	 *
	 * @author Konstantin Andreyev - April, 2016
	 */
	public static String trimCommonSuffixes(String lastName) {
		String result = null;
		if (lastName != null) {
			result = lastName.toLowerCase();
			if (lastName.length() > 2) {
				for (String commonSuffixe : commonSuffixes) {
					if (result.endsWith(commonSuffixe)) {
						result = result.replaceAll(commonSuffixe, "");
						break;
					}
				}
			}
		}
		//
		return result;
	}

	public static String[][] cp = new String[][] { new String[] { "de la ", "dela" }, new String[] { "dela ", "dela" },
			new String[] { "del ", "del" }, new String[] { "da ", "da" }, new String[] { "dos ", "dos" }, new String[] { "le ", "le" },
			new String[] { "de ", "de" }, new String[] { "van ", "van" }, new String[] { "st ", "st" }, new String[] { "st. ", "st" },
			new String[] { "di ", "di" }, new String[] { "von ", "von" }, new String[] { "du ", "du" } };

	/**
	 * Adds common prefix to name by removing space that separates common prefix
	 * from it.
	 *
	 * @param lastName
	 * @returns {java.lang.String} name
	 *
	 * 
	 */
	public static String mergeCommonPrefixes(String lastName) {
		String result = null;
		if (lastName != null) {
			result = lastName.toLowerCase();
			if (lastName.length() > 2) {
				for (String[] element : cp) {
					int idx = result.indexOf(element[0]);
					if (idx == -1) {
						continue;
					} else if (idx == 0 || result.charAt(idx - 1) == ' ') {
						result = result.replace(element[0], element[1]);
						break;
					}
				}
			}
		}
		return result;
	}
  
  public static String trimAndNormalizeWhiteSpaces(String str) {
		if (str == null) {
			return str;
		} else {
			return str.trim().replaceAll("\\s{2,}", " ");
		}
	}
  
  
 public static String STRING_OF_ALPHA_NUM_CHARS = "0123456789abcdefghijklmnopqrstuvwxyz";

	public static String generateRandomDigit() {
		return Integer.toString(new java.util.Random().nextInt(10));
	}

	public static String generateRandomAlphaNumericSymbol() {
		return Character.toString(STRING_OF_ALPHA_NUM_CHARS.charAt(new java.util.Random().nextInt(36)));
	}

	public static Boolean[] SAMA_IS_DIGIT_ONLY = new Boolean[] { false, false, true, false, true, false, false };
	public static Integer SAMA_LENGTH = SAMA_IS_DIGIT_ONLY.length;

	public static String generateRandomSamAccountName(String prefix) {
		String result = prefix == null ? "" : prefix;
		Integer reqdLength = SAMA_LENGTH;
		while (result.length() < reqdLength) {
			if (SAMA_IS_DIGIT_ONLY[result.length()]) {
				result += generateRandomDigit();
			} else {
				result += generateRandomAlphaNumericSymbol();
			}
		}
		return result;
	}

	// Auto Logic
	// Minimum characters 3 and maximum character 7.
	// Format 1: All characters of last name and rotating characters for
	// first name. e.g. Joe Alan. jalan,joalan,joealan
	public static List generateSAMAccountNames(String givenName, String sn) {
		Set result = new LinkedHashSet();
		String firstName = "";
		if (givenName != null) {
			firstName =givenName.toLowerCase().replaceAll("\\W", "");
			if (firstName.length() > 6) {
				firstName = firstName.substring(0, 6);
			}
		}
		String lastname = "";
		if (sn != null) {
			lastname = sn.toLowerCase().replaceAll("\\W", "");
			if (lastname.length() > 6) {
				lastname = lastname.substring(0, 6);
			}
		}
		String sAMAccountName = "";
		if (firstName.length() > 0 && lastname.length() > 0) {
			for (int i = 1; i <= firstName.length(); i++) {
				sAMAccountName = firstName.substring(0, i) + lastname;
				if (sAMAccountName.length() > 7) {
					sAMAccountName = sAMAccountName.substring(0, 7);
				}
				if (sAMAccountName.length() > 2) {
					result.add(sAMAccountName);
				}
			}
		}

		if (firstName.length() < 5) {
			String initialStr = firstName + lastname;
			if (initialStr.length() > 6) {
				initialStr = initialStr.substring(0, 6);
			}
			for (int i = initialStr.length(); i > firstName.length(); i--) {
				sAMAccountName = initialStr.substring(0, i);
				if (sAMAccountName.length() > 2) {
					result.add(sAMAccountName);
				} else {
					break;
				}
			}
		}

		// Generate random sAMAAccountNames also
		String prefix = "";
		if (Util.isNotNullOrEmpty(firstName)) {
			prefix = firstName;
		} else if (Util.isNotNullOrEmpty(lastname)) {
			prefix = lastname;
		}
		if (prefix.length() > 2) {
			prefix = prefix.substring(0, 2);
		}
		int size = 25 - result.size();
		for (int i = 0; i < size; i++) {
			result.add(generateRandomSamAccountName(prefix));
		}
		return new ArrayList(result);
	}
	
 public static List generateEmailAddresses(String firstName, String lastName){
        String mail="";
        String defaultMail= firstName+"."+lastName+"@cityofboston.gov";
        List maiList = new ArrayList();
        maiList.add(defaultMail);
        for(int i=1; i<25;i++){

            mail=firstName+"."+lastName+i+"@boston.gov";
            maiList.add(mail);
        }
        return maiList;
    }
  
  
public static Collection cobRetrieveAccountsFromADEnvironment(String searchFilter, String[] attributesToReturn, String baseDN,
			Hashtable env) throws GeneralException, NamingException {
		Collection searchResults = new ArrayList();
		DirContext adCtx = null;
		NamingEnumeration response = null;
		try {
			//String baseDN = adEnv.getKey();
			adCtx = new InitialDirContext(env);
			SearchControls searchCtls = new SearchControls();
			searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);
			searchCtls.setReturningAttributes(attributesToReturn);
			searchCtls.setReturningObjFlag(false);
			response = adCtx.search(baseDN, searchFilter, searchCtls);
			while (response.hasMore()) {
				searchResults.add(response.next());
			}
		} catch (Throwable t) {
			t.printStackTrace();
			throw t;
		} finally {
			if (response != null) {
				try {
					response.close();
				} catch (NamingException ignore) {//NOPMD - suppress PMD warning (ignore Exception on context close)
				}
			}
			if (adCtx != null) {
				try {
					adCtx.close();
				} catch (NamingException ignore) {//NOPMD - suppress PMD warning (ignore Exception on context close)
				}
			}
		}

		return searchResults;
	}

	public static Collection cobRetrieveAccountsFromADEnvironment(String searchFilter, String[] attributesToReturn,
			Entry adEnv) throws GeneralException, NamingException {

		return cobRetrieveAccountsFromADEnvironment(searchFilter, attributesToReturn, adEnv.getKey(), adEnv.getValue());
	}

	public static boolean isInAD(String searchFilter, SailPointContext context) throws GeneralException, NamingException {
		boolean isSAMAccountNameInAD = false;
		Map adEnvironments = getActiveDirectoryEnvironments("Dev_CityHall_AD", context);
		for (Entry adEnv : adEnvironments.entrySet()) {
			Collection  results = cobRetrieveAccountsFromADEnvironment(searchFilter, new String[] {"sAMAccountName"}, adEnv);
			isSAMAccountNameInAD = results.size() > 0;
			if (isSAMAccountNameInAD) {
				break;
			}
		}
		//
		return isSAMAccountNameInAD;
	}

	public static boolean isSAMAccountNameInAD(String sAMAccountName, SailPointContext context) throws GeneralException, NamingException {
		String searchFilter = "(sAMAccountName=" + sAMAccountName + ")";
		//
		return isInAD(searchFilter, context);
	}
  
  	public static Map getActiveDirectoryEnvironments(String adApplicationName, SailPointContext context)
			throws GeneralException {
		Map dnToDomainEnvironmentMap = new HashMap();
		Application appAD = context.getObjectByName(Application.class, adApplicationName);
		if (appAD != null) {
			sailpoint.object.Attributes adAppAttrs = appAD.getAttributes();
			if (adAppAttrs != null) {
			
				List configs = adAppAttrs.getList("domainSettings");
				for (Map config : configs) {
					String bindDN = (String) config.get("user");
					String pword = (String) config.get("password");
					String domainDN = (String) config.get("domainDN");
				  String port="389";
					String host=(String) config.get("forestName");
					Hashtable ldapEnv = new Hashtable();
					ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
					ldapEnv.put(Context.PROVIDER_URL, "ldap://" + host + ":" + port);
					ldapEnv.put(Context.REFERRAL, "follow");
					ldapEnv.put(Context.SECURITY_AUTHENTICATION, "simple");
					ldapEnv.put(Context.SECURITY_PRINCIPAL, bindDN);
					ldapEnv.put(Context.SECURITY_CREDENTIALS, context.decrypt(pword));

					dnToDomainEnvironmentMap.put(domainDN, ldapEnv);
				}
			}
		}
		return dnToDomainEnvironmentMap;
	}
	
	
public static boolean isSAMAccountNameInIIQ(String sAMAccountName, SailPointContext context) throws GeneralException {
		boolean isSAMAccountNameInIIQ = false;
		QueryOptions qo = new QueryOptions();
		qo.addFilter(Filter.ignoreCase(Filter.eq("sAMAccountName", sAMAccountName)));
		isSAMAccountNameInIIQ = !Util.isEmpty(context.getObjects(Identity.class, qo));
		
		if (!isSAMAccountNameInIIQ) {
			qo = new QueryOptions();
			qo.addFilter(Filter.ignoreCase(Filter.eq("name", sAMAccountName)));
			isSAMAccountNameInIIQ = !Util.isEmpty(context.getObjects(Identity.class, qo));
		}
		if (!isSAMAccountNameInIIQ) {
			qo = new QueryOptions();
			qo.addFilter(Filter.ignoreCase(Filter.like("name", "\\" + sAMAccountName, MatchMode.END)));
			isSAMAccountNameInIIQ = !Util.isEmpty(context.getObjects(Identity.class, qo));
		}
		//
		return isSAMAccountNameInIIQ;
	}


public static boolean isMailInAD(String mail, SailPointContext context) throws GeneralException, NamingException {
		String searchFilter = "(mail=" + mail + ")";
		
		return isInAD(searchFilter, context);
	}

	

	public static boolean isMailInIIQ(String mail, SailPointContext context) throws GeneralException {
		boolean isMailInIIQ = false;
		QueryOptions qo = new QueryOptions();
		qo.addFilter(Filter.ignoreCase(Filter.eq("email", mail)));
		isMailInIIQ = !Util.isEmpty(context.getObjects(Identity.class, qo));
		//
		return isMailInIIQ;
	}

	public static boolean isMailUnique(String mail, SailPointContext context) throws GeneralException, NamingException {
		boolean isMailUnique = true;
		if (mail != null) {
			if (isMailInAD(mail, context)) {
				isMailUnique = false;
			} else if (isMailInIIQ(mail, context)) {
				isMailUnique = false;
			}
		}
		//
		return isMailUnique;
	}
	
  public String generateUniqueEmailAddress(String firstName, String lastName, SailPointContext context) throws GeneralException, NamingException {
      List emailAddresses= generateEmailAddresses(firstName, lastName);
      String uniqueEmailAddress = null;
    for(Object emailAddressObj: emailAddresses){
      String emailAddress = (String) emailAddressObj;
      if(isMailUnique(emailAddress,context)){
        uniqueEmailAddress= emailAddress;
        break;
        
        
      }
    }
    
    if(uniqueEmailAddress== null){
      		throw new RuntimeException("Unable to generate unique emailAddress for \"" + firstName + "\" \"" + lastName + "\"");
		} else {
			return uniqueEmailAddress;
		}
   }

  
  public String generateUniqueSAMAccountName(String givenName, String sn, SailPointContext context) throws GeneralException, NamingException {
		List sAMAccountNames = generateSAMAccountNames(givenName, sn);
		
		
		// Check
		String uniqueSAMAccountName = null;
		for (Object sAMAccountNameObj : sAMAccountNames) {
			String sAMAccountName = (String) sAMAccountNameObj;
			if (!isSAMAccountNameInIIQ(sAMAccountName, context) && !isSAMAccountNameInAD(sAMAccountName, context) ) {
				uniqueSAMAccountName = sAMAccountName;
				break;
			}
		}
		//
		if (uniqueSAMAccountName == null) {
			throw new RuntimeException("Unable to generate unique sAMAccountName for \"" + givenName + "\" \"" + sn + "\"");
		} else {
			return uniqueSAMAccountName;
		}
	}
  
  public String getADHost(String adApplicationName, SailPointContext context) throws GeneralException {
    	String host="";
    Map dnToDomainEnvironmentMap = new HashMap();
		Application appAD = context.getObjectByName(Application.class, adApplicationName);
		if (appAD != null) {
			sailpoint.object.Attributes adAppAttrs = appAD.getAttributes();
			if (adAppAttrs != null) {
			
				List configs = adAppAttrs.getList("domainSettings");
				for (Map config : configs) {
				
					host=(String) config.get("forestName");
              break;
        }
       
      }
       
  }
    return host;
  }
  
  	public static String[] getArrayOfCommonNames(Collection sdsCNs, String sn) {
		Collection commonNames = new LinkedHashSet();
		if (sdsCNs != null) {
			String sdsCN = sdsCNs.iterator().next();
			if (sdsCN.contains(",")) {
				String[] tokens = sdsCN.split(",");
				StringBuilder sb = new StringBuilder();
				for (String token : tokens) {
					if (sb.length() > 0) {
						sb.insert(0, " ");
					}
					sb.insert(0, token.trim());
				}
				sdsCN = sb.toString();
			}
			sdsCN = sdsCN.replace(".", " ");
			sdsCN = trimAndNormalizeWhiteSpaces(sdsCN);
			sdsCN = trimCommonSuffixes(sdsCN);
			sdsCN = mergeCommonPrefixes(sdsCN);
			sdsCN = toStartCase(sdsCN);
			sdsCN = normalizeName(sdsCN);
			
			String lastName = sn.toLowerCase();
			String mi = null;
			LinkedHashSet givenNamesSet = new LinkedHashSet();
			Collection names = Arrays.asList(sdsCN.split(" "));
			Iterator namesItr = names.iterator();
			while (namesItr.hasNext()) {
				String name = namesItr.next();
				if (namesItr.hasNext()) {
					if (name.length() == 1 && names.size() > 2) {
						mi = name + ".";
					} else {
						givenNamesSet.add(name);
					}
				}
			}
			//
			LinkedList givenNames = new LinkedList(givenNamesSet);
			while (true) {
				commonNames.add(makeCommonName(givenNames, mi, lastName));
				if (givenNames.size() > 1) {
					givenNames.removeLast();
				} else {
					break;
				}
			}
			if (mi == null && givenNames.size() > 0) {
				String firstName = givenNames.getFirst();
				mi = new String(firstName.charAt(0) + ".");
				givenNames = new LinkedList(givenNamesSet);
				while (true) {
					commonNames.add(makeCommonName(givenNames, mi, lastName));
					if (givenNames.size() > 1) {
						givenNames.removeLast();
					} else {
						break;
					}
				}
			}
			for (String letter : AUC) {
				String initial = letter + ".";
				if (!initial.equalsIgnoreCase(mi)) {
					givenNames = new LinkedList(givenNamesSet);
					while (true) {
						commonNames.add(makeCommonName(givenNames, initial, lastName));
						if (givenNames.size() > 1) {
							givenNames.removeLast();
						} else {
							break;
						}
					}
				}
			}
		}
		return commonNames.toArray(new String[commonNames.size()]);
	}

	public static String makeCommonName(List givenNames, String mi, String lastName) {
		StringBuilder sb = new StringBuilder();
		for (String givenName : givenNames) {
			sb.append(givenName).append(" ");
		}
		if (mi != null) {
			sb.append(mi).append(" ");
		}
		sb.append(lastName);
		return sb.toString().trim();
	}
	
	public String makeUniqueDN(String baseDN, Collection sdsCNs, String sn, SailPointContext context)
			throws GeneralException, NamingException {
		String uniqueDN = null;
		DirContext ctx = null;
		NamingEnumeration response = null;
		try {
			String[] commonNames = getArrayOfCommonNames(sdsCNs, sn);
			Hashtable env = getADEnvironmentForDistinguishedName(baseDN, context);
			ctx = new InitialDirContext(env);
			SearchControls searchCtls = new SearchControls();
			searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);
			searchCtls.setReturningAttributes(new String[] { ADAttribute.CN });
			searchCtls.setReturningObjFlag(false);
			for (String commonName : commonNames) {
				String searchFilter = "(cn=" + commonName + ")";
				response = ctx.search(baseDN, searchFilter, searchCtls);
				if (!response.hasMore()) {
					uniqueDN = "cn=" + commonName + "," + baseDN;
					break;
				}
				response.close();
			}
		} catch (Throwable t) {
			t.printStackTrace();
			throw t;
		} finally {
			if (response != null) {
				try {
					response.close();
				} catch (NamingException ignore) {//NOPMD - suppress PMD warning (ignore Exception on context close)
				}
			}
			if (ctx != null) {
				try {
					ctx.close();
				} catch (NamingException ignore) {//NOPMD - suppress PMD warning (ignore Exception on context close)
				}
			}
		}
		
		return uniqueDN;
	}
  
//  Map resultMap =getActiveDirectoryEnvironments("Dev_CityHall_AD", context);
//  return resultMap;
//  return isMailUnique("pankaj1232@likemindsconsulting.com",context);
//  return isSAMAccountNameInAD("Pbc123",context);
  
//  return generateUniqueEmailAddress("Greg","McCarthy",context);
  
//return  getADHost("Dev_CityHall_AD", context);
  List nameList= new ArrayList();
  nameList.add("Pankaj");
  return makeCommonName(nameList, "B", "Chhetri");
  ]]></Source>
</Rule>
